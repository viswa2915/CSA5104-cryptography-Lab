def mod_inverse(a, m):
    """Find modular inverse of a under modulo m."""
    a = a % m
    for x in range(1, m):
        if (a * x) % m == 1:
            return x
    return -1


def affine_cipher_encrypt(plaintext, a, b):
    """Encrypt plaintext using Affine Cipher."""
    ciphertext = ""
    for ch in plaintext:
        if ch.isalpha():
            ch = ch.upper()
            encrypted_char = chr(((a * (ord(ch) - ord('A')) + b) % 26) + ord('A'))
            ciphertext += encrypted_char
        else:
            ciphertext += ch
    return ciphertext


def affine_cipher_decrypt(ciphertext, a, b):
    """Decrypt ciphertext using Affine Cipher."""
    decrypted = ""
    a_inv = mod_inverse(a, 26)
    if a_inv == -1:
        raise ValueError(f"No modular inverse for a={a} under mod 26.")

    for ch in ciphertext:
        if ch.isalpha():
            ch = ch.upper()
            decrypted_char = chr(((a_inv * ((ord(ch) - ord('A') - b)) % 26) + ord('A')))
            decrypted += decrypted_char
        else:
            decrypted += ch
    return decrypted


plaintext = input("Enter plaintext: ")
a = int(input("Enter value of a: "))
b = int(input("Enter value of b: "))

if a % 2 == 0 or a % 13 == 0:
    print("Invalid 'a' value. It must be coprime with 26.")
else:
    ciphertext = affine_cipher_encrypt(plaintext, a, b)
    decrypted = affine_cipher_decrypt(ciphertext, a, b)

    print("Ciphertext:", ciphertext)
    print("Decrypted:", decrypted)
